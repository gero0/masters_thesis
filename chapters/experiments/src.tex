\chapter{Badania eksperymentalne}

\section{Zaimplementowane algorytmy}
\subsection{Próbkowanie dwufazowe} \label{section:tp}
Próbkowanie dwufazowe swoją nazwę zawdzięcza procesowi próbkowania składającemu się z dwóch oddzielnych faz
- próbkowania wierzchołków oraz próbkowania krawędzi - wykonywanych jedna po drugiej.
Istotną zaletą tego podejścia jest jego stosunkowo prosta implementacja.

Zaimplementowany algorytm pochodzi z pracy\cite{DBLP:conf/depcos/BozejkoGNAB18}.
Został on przygotowany specjalnie do próbkowania przestrzeni rozwiązań problemu komiwojażera.
Próbkowanie wierzchołków odbywa się poprzez generowanie losowych rozwiązań, a następnie ich optymalizacji algorytmem 2-opt.
Próbkowanie krawędzi polega na wielokrotnym poddaniu każdego ze znalezionych wcześniej lokalnych optimów $n_i$ operacji perturbacji typu 2-exchange,
a następnie poddaniu powstałego rozwiązania optymalizacji algorytmem 2-opt typu \textit{first-improvement} uzyskując w ten sposób lokalne optimum $n_j$.
Następnie dodawana jest krawędź między $n_i$ a $n_j$, lub - jeśli już taka istnieje - jej waga jest zwiększana o 1.

Algorytm przyjmuje trzy parametry: pożądaną liczbę wierzchołków do wygenerowania ($n_{max}$), maksymalną liczbę prób generowania wierzchołka ($n_{att}$)
oraz maksymalną liczbę prób generowania krawędzi($e_{att}$).
Implementacja zastosowana w tej pracy dodatkowo powtarza cały proces kilkukrotnie, za każdym razem zapisując zebrane próbki do pliku.

Algorytm w postaci pseudokodu został przedstawiony na listingu \ref{alg:tp}.

\subsection{Snowball} \label{section:snowball}
Próbkowanie typu Snowball wywodzi się z techniki używanej w badaniach z dziedziny socjologii, w której ludzie należący do próby z populacji
rekrutują kolejnych uczestników badania spośród swoich znajomych.
W kontekście badania przestrzeni rozwiązań technika ta została zaprezentowana w pracy\cite{DBLP:conf/ppsn/VerelDOT18}, gdzie została wykorzystana
do próbkowanie przestrzeni problemu kwadratowego przypisania (QAP).

Próbkowanie składa się z etapów procedury \textit{snowball} próbkującej "wgłąb" i losowego spaceru(ang. \textit{random walk}).
Próbkowanie \textit{snowball} polega na wybraniu rozwiązania startowego i przeszukaniu jego najbliższego sąsiedztwa.
Następnie operacja ta jest powtarzana dla każdego rozwiązania w tym sąsiedztwie. Proces powtarza się aż do osiągnięcia z góry ustalonej głebokości
przeszukiwania. Następnie rozpoczyna się procedura losowego spaceru - wybierane jest kolejne rozwiązanie startowe
ze zbioru sąsiadów poprzedniego rozwiązywania startowego (lub rozwiązanie losowe, jeśli to sąsiedztwo jest puste) i proces \textit{snowball}
rozpoczyna się od nowa. Procedura jest powtarzana aż osiągnięty zostanie z góry ustalony limit długości spaceru.

Zaimplementowany algorytm jest próbą adaptacji tej techniki do zadania przeszukiwania przestrzeni
problemu komiwojażera. Do najważniejszych modyfikacji należy zastąpienie funkcji optymalizacji lokalnej \textit{hillclimb}
optymalizacją 2opt, implementacja odpowiedniej funkcji celu oraz operacji mutacji typu 2-exchange.

Algorytm w postaci pseudokodu został przedstawiony na listingu \ref{alg:snowball}.

\vspace{1em}

\begin{algorithm}[H]
    \caption{Próbkowanie dwufazowe - pseudokod}\label{alg:tp}

    \KwData{\\
        \Indp \Indp
        $n_{max}$ - żądana liczba wierzchołków\\
        $n_{att}$ - liczba prób generowania wierzchołków\\
        $e_{att}$ - liczba prób generowania krawędzi\\
        $n_{runs}$ - liczba powtórzeń\\
        $D$ - stała D krawędzi
    }

    \vspace{1em}

    $N \gets \{\}$\;
    $E \gets \{\}$\;
    \For{$i\gets1$ \KwTo $n_{runs}$}{
        $probkujWierzcholki(N, n_{max}, n_{att})$\;
        $probkujKrawedzie(N, E, e_{att})$\;
        $zapiszDoPliku(N, E)$\;
    }
    \vspace{1em}

    \SetKwFunction{FV}{probkujWierzcholki}
    \SetKwProg{Fn}{function}{:}{}

    \Fn{\FV{$N, n_{max}, n_{att}$}}{
        \For{$i\gets1$ \KwTo $n_{max}$}{
            \For{$i\gets1$ \KwTo $n_{att}$}{
                $s \gets losoweRozwiazanie()$\;
                $s \gets 2opt(s)$\;
                $N \gets N \cup \{s\}$\;
            }
        }
    }
    \textbf{end}

    \vspace{1em}

    \SetKwFunction{FE}{probkujKrawedzie}

    \Fn{\FE{$N, E, e_{att}$}}{
        \ForEach{$n \in{N}$}{
            \For{$i\gets1$ \KwTo $e_{att}$}{
                $s \gets 2exchangeMutacja(n, D)$\;
                $s \gets 2optFirstImprovement(s)$\;
                \If{$s \in{N}$}{
                    $E \gets E \cup \{(n, s)\}$\;
                    $w_{ns} \gets w_{ns} + 1$\;
                }
            }
        }
    }
    \textbf{end}

    \vspace{1em}

\end{algorithm}

\begin{algorithm}[p]
    \caption{Próbkowanie snowball - pseudokod}\label{alg:snowball}

    \KwData{\\
        \Indp \Indp
        $w_{len}$ - długość losowego spaceru\\
        $m$ - liczba prób przeszukania sąsiedztwa\\
        $depth$ - głębokość przeszukiwania\\
        $D$ - stała D krawędzi\\
        $s_{tresh}$ - interwał zapisu
    }

    \vspace{1em}
    $s_1 \gets losoweRozwiazanie()$\;
    $n_1 \gets 2opt(s_1)$\;

    $N \gets \{ n_1 \}$\;
    $E \gets \{\}$\;
    \For{$j\gets1$ \KwTo $n_{runs}$}{
        \For{$i\gets1$ \KwTo $w_{len}$}{
            $snowball(n_i, m, depth)$\;
            $n_{i+1} \gets losowySpacer(n_i)$\;
        }
    }
    $zapiszDoPliku(N, E)$\;
    \vspace{1em}

    \SetKwFunction{FS}{snowball}
    \SetKwProg{Fn}{function}{:}{}

    \Fn{\FS{$n, m, depth$}}{
        \If{$d > 0$}{
            \For{$i\gets1$ \KwTo $m$}{
                $s \gets 2opt(2exchangeMutacja(n, D))$\;
                $N \gets N \cup \{ s \}$\;
                \If{$|N| \hspace{0.5em} mod \hspace{0.5em} s_{tresh} = 0$}{
                    $zapiszDoPliku(N, E)$\;
                }
                \uIf{$(n, s) \in{E}$}{
                    $w_{ns} \gets w_{ns} + 1$\;
                }
                \Else{
                    $E \gets E \cup \{ (n, s) \}$\;
                    $w_{ns} \gets 1$\;
                    $snowball(s, m, d-1)$\;
                }
            }
        }
    }
    \textbf{end}

    \vspace{1em}

    \SetKwFunction{FW}{losowySpacer}

    \Fn{\FW{$n_i$}}{
        $neighbours \gets \{ s: (n_i, s) \in E \land s \notin \{ n_0...n_i \} \}$\;
        \uIf{$neighbours \neq \emptyset $}{
            $n_{i+1} \gets losowyElementZeZbioru(neighbours)$\;
        }
        \Else{
            $s \gets losoweRozwiazanie()$\;
            $n_{i+1} \gets 2opt(s)$\;
            $N \gets N \cup \{ n_{i+1} \}$\;
            \If{$|N| \hspace{0.5em} mod \hspace{0.5em} s_{tresh} = 0$}{
                $zapiszDoPliku(N, E)$\;
            }
        }
        \Return $n_{i+1}$
    }
    \textbf{end}

    \vspace{1em}

\end{algorithm}

\newpage

\subsection{Przegląd zupełny}
Ze względu na złożoność problemu komiwojażera przegląd zupełny można zastosować tylko do bardzo małych instancji problemu.
Przegląd polega na wygenerowaniu wszystkich możliwych rozwiązań danej instancji, wykonaniu na nich optymalizacji 2-opt w celu znalezienia
optimów lokalnych a następnie znalezieniu krawędzi oraz obliczeniu ich wag. Dla każdego z rozwiązań generowane są wszystkie
permutacje, które mogą powstać poprzez D-krotne wykonanie na rozwiązaniu operacji 2-exchange. Jeśli wśród tych permutacji znajduje się jedno ze znalezionych wcześniej
lokalnych optimów, oznacza to, że spełniony jest warunek \ref{eq:escape_edge_cond} i dodawana jest nowa krawędź lub zwiększona zostaje waga istniejącej.

\begin{algorithm}[]
    \caption{Przegląd zupełny}\label{alg:exhaustive}
    $S \gets \{\}$\;
    $P \gets wygenerujWszystkiePermutacje()$\;
    \ForEach{$p \in P$}{
        $lo \gets 2opt(p)$\;
        $S \gets S \cup \{(p, lo)\}$\;
    }

    \SetKwProg{Fn}{function}{:}{}

    \ForEach{$(p, lo) \in S$}{
        \ForEach{$n \in N$}{
            \If{$wZasiegu2Exchange(p, n, D)$}{
                \uIf{$(n, lo) \in E$}{
                    $w_{n, lo} \gets w_{n, lo} + 1$\;
                }\Else{
                    $E \gets E \cup \{(n, lo)\}$\;
                    $w_{n, lo} = 1$\;
                }
            }
        }
    }

    \SetKwFunction{FI}{wZasiegu2Exchange}

    \vspace{1em}

    \Fn{\FI{$p, n, D$}}{
        $permutacje \gets \{p\}$\;
        \For{$i \in 1..D$}{
            $nowe\_perm \gets \{\}$\;
            \ForEach{$perm \in permutacje$}{
                $pochodne\_perm \gets 2exchangeWszystkiePermutacje(permutacje)$\;
                \ForEach{$poch\in pochodne\_perm$}{
                    \If{poch = n}{
                        \Return{true}\;
                    }
                    $nowe\_perm \gets nowe\_perm \cup \{poch\}$\;
                }
            }
            $permutacje \gets nowe\_perm$\;
        }
        \Return{false}\;
    }
    \textbf{end}

\end{algorithm}

\section{Instancje testowe}
Do badań wykorzystano instancje testowe wygenerowane losowo oraz wybrane instancje ze zbioru TSPLIB.
Zaimplementowano trzy generatory tworzące różne typy instancji testowych: z miastami rozłożonymi równomiernie,
z miastami rozłożonymi w klastrach oraz z miastami ułożonymi na siatce.
Wygenerowano instancje testowe każdego z trzech typów instancji losowych o rozmiarach 7, 8, 9, 10, 11 oraz 20, 50, 80 i 100.
Uzyskano w ten sposób 27 instancji problemu.
Ze zbioru TSPLIB wybrano instancje o podobnych rozmiarach: \textbf{burma14}, \textbf{ulysses22}, \textbf{att48}, \textbf{berlin52}, \textbf{pr76}, \textbf{eil76}, \textbf{rat99},
\textbf{bier127}.
W sumie badanie przeprowadzono na 35 instancjach problemu.

\subsection*{Miasta rozmieszczone równomiernie}
Generator losowo rozmieszcza miasta na wirtualnej planszy o ustalonym rozmiarze.\\
Współrzędne miast generowane są losowo z rozkładu równomiernego.
W dalszej części dokumentu instancje wygenerowane tym generatorem będą nazywane \textbf{uniform\_<liczba miast>}.

Przykład wygenerowanej instancji został przedstawiony na rysunku \ref{fig:uniform_example}.

\subsection*{Miasta rozmieszczone w klastrach}
Miasta umieszczane są blisko siebie w kilku grupach oddzielonych większymi odległościami.
W dalszej części dokumentu instancje wygenerowane tym generatorem będą nazywane \textbf{cliques\_<liczba miast>}.
Przykład wygenerowanej instancji został przedstawiony na rysunku \ref{fig:clique_example}.


\subsection*{Miasta rozmieszczone na siatce}
Miasta umieszczane są na siatce, w stałej odległości od swoich sąsiadów.
W dalszej części dokumentu instancje wygenerowane tym generatorem będą nazywane \textbf{grid\_<liczba miast>}.
Przykład wygenerowanej instancji został przedstawiony na rysunku \ref{fig:grid_example}.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.46\textwidth]{chapters/experiments/img/uniform_example.png}
    \caption{Wizualizacja przykładowej wygenerowanej instancji z miastami rozmieszczonymi równomiernie dla 100 miast}
    \label{fig:uniform_example}
\end{figure}

\newpage

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.60\textwidth]{chapters/experiments/img/clique_example.png}
    \caption{Wizualizacja przykładowej wygenerowanej instancji z miastami rozmieszczonymi w klastrach dla 100 miast}
    \label{fig:clique_example}
\end{figure}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.60\textwidth]{chapters/experiments/img/grid_example.png}
    \caption{Wizualizacja przykładowej wygenerowanej instancji z miastami rozmieszczonymi na siatce dla 100 miast}
    \label{fig:grid_example}
\end{figure}

\section{Opis badań}

Badania podzielono na trzy etapy: Porównanie wartości metryk z przeglądem zupełnym dla małych instancji,
badanie stabilności średnich instancji, oraz badanie stabilności dużych instancji.

W tym rozdziale przedstawione zostaną tabele i wykresy wygenerowane z wyników próbkowania.
Nazwy metryk są identyczne z nazwami objaśnionymi w rozdziale \ref{sec:metrics}.
Ponadto występują pojęcia:

\begin{itemize}
    \item node\_count - liczba wierzchołków,
    \item edge\_count - liczba krawędzi,
    \item opt\_count - liczba wywołań funkcji 2opt,
    \item oracle\_count - liczba wykonanych obliczeń długości ścieżki (metodą obliczenia przyrostu długości stosowanej w 2opt).
    \item twophase - algorytm dwufazowy
\end{itemize}

Wszystkie badania wykonano wykorzystując model krawędzi typu \textit{Escape Edges} z parametrem $D$ o wartości 2.

\subsection{Porównanie wartości metryk dla małych instancji}
Dla małych instancji wygenerowanych losowo (uniform, grid, cliques) o rozmiarach 7 do 11
możliwe jest wykonanie przeglądu zupełnego.
Na tych instancjach wykonano próbkowanie algorytmami dwufazowym oraz snowball, z różnym zestawem parametrów.

Dla algorytmu dwufazowego wykonano próbkowanie dla różnych wartości parametru $n_{max}$ (liczby żądanych wierzchołków): 10, 100, 1000 oraz 10000.
Parametry $n_{att}$, $e_{att}$ ustawiono na równe $n_{max}$, a parametr $n_{runs}$ na 1.

Dla algorytmu \textit{snowball} wykonano próbkowanie dla różnych wartości parametru $w_{len}$ (długości losowego spaceru): 1, 10, 100 oraz 1000.
Pozostałe parametry ustawiono następująco: $m$ = 100, $depth$ = 3.

Uzyskane wartości porównano z wartościami uzyskanymi z przeglądu zupełnego.
Wyniki przedstawiono w tabelach od \ref{tab:comp_uniform_7_snowball} do \ref{tab:comp_grid_11_twophase}.
W tabeli przedstawiono wartości metryk uzyskane w przeglądzie zupełnym oraz wartości uzyskane z próbkowania.
Dodatkowo w nawiasie podana została wartość błędu obliczona z wzoru \ref{eq:relError}.
\begin{equation}
    \label{eq:relError}
    E = \frac{|R - S|}{R} \cdot 100\%
\end{equation}
Gdzie:
\begin{itemize}
    \item E - wartość błędu
    \item R - wartość rzeczywista (z przegl. zupełnego)
    \item S - wartość otrzymana z próbkowania.
\end{itemize}

Wartości, dla których błąd nie wyniósł 0 zostały dodatkowo oznaczone w tabeli grubą czcionką.

\include{tables.tex}

TODO: Komentarz do wyników.

\subsection{Badanie stabilności dla średnich instancji}
Instancje \textbf{burma14}, \textbf{ulysses22} ze zbioru tsplib oraz wygenerowane instancje
\textbf{cliques\_20}, \textbf{uniform\_20} oraz \textbf{grid\_20} są zbyt duże, by wykonać dla nich przegląd zupełny,
ale zbyt małe, żeby próbkować je z takimi samymi parametrami, jak większe instancje.
Z tego powodu badania przeprowadzone dla tych instancji umieszczono w osobnej sekcji.
Dla instancji tego typu wykonano bardziej szczegółowe próbkowanie z mniejszymi interwałami zapisu.

Próbkowanie algorytmem snowball wykonano z następującymi parametrami:
\begin{itemize}
    \item $w_{len}$ - długość losowego spaceru - 10000
    \item $m$ - liczba prób przeszukania sąsiedztwa - 100
    \item $depth$ - głębokość przeszukiwania - 3
\end{itemize}
Zapis wyników wykonywano przy każdym znalezionym wierzchołku.
Wyjątkiem była instancja grid\_20 - tu zapis wykonywano co 100 wierzchołków z powodu dużej ilości optimów lokalnych.

Próbkowanie algorytmem dwufazowym przeprowadzono z następującymi parametrami:
\begin{itemize}
    \item $n_{max}$ - żądana liczba wierzchołków - 1
    \item $n_{att}$ - liczba prób generowania wierzchołków - 1000
    \item $e_{att}$ - liczba prób generowania krawędzi - 10
    \item $n_{runs}$ - liczba powtórzeń - 1000
\end{itemize}
Zapis wyników wykonywano po zakończeniu każdego powtórzenia.

Utworzono wykresy przedstawiające zależność wartości miar od liczby spróbkowanych wierzchołków.
Przedstawiono je na rysunkach od \ref{fig:small_edge_count} do \ref{fig:small_missed}.

\def\metricsSmall{
    {edge_count/Liczba krawędzi},
    {edge_to_node/Stosunek liczby krawędzi do liczby wierzchołków},
    {assortativity_deg/Współczynnik różnorodności grafu},
    {avg_fitness/Średnia wartość funkcji celu w znalezionych optimach lokalnych},
    {conrel/Współczynnik conrel},
    {density/Gęstość grafu},
    {distLO/Współczynnik distLO},
    {reciprocity/Współczynnik wzajemności grafu},
    {largest_clique_size/Rozmiar największej kliki w grafie},
    {num_sources/Liczba źródeł w grafie},
    {num_sinks/Liczba ścieków w grafie},
    {num_subsinks/Liczba subsinks w grafie},
    {avg_in_degree/Średni stopień wchodzący wierzchołków w grafie},
    {max_in_degree/Maksymalny stopień wchodzący wśród wierzchołków w grafie},
    {max_out_degree/Średni stopień wychodzący wierzchołków w grafie},
    {avg_out_degree/Maksymalny stopień wychodzący wśród wierzchołków w grafie},
    {avg_loop_weight/Średnia waga pętli w grafie},
    {avg_path_len/Średnia waga pętli w grafie},
    {avg_go_path_len/Średnia długość istniejących ścieżek do globalnego optimum},
    {max_go_path_len/Długość najdłuższej istniejącej ścieżki do globalnego optimum},
    {go_path_ratio/Stosunek liczby wierzchołków, z których istnieje ścieżka do globalnego optimum do liczby wszystkich wierzchołków},
    {funnel_num/Liczba lejów w przestrzeni},
    {max_funnel_size/Rozmiar największego leja w przestrzeni},
    {mean_funnel_size/Średni rozmiar lejów w przestrzeni},
    {num_cc/Liczba spójnych podgrafów},
    {largest_cc/Rozmiar największego spójnego podgrafu},
    {largest_cc_radius/Promień największego spójnego podgrafu}}


\foreach \metric/\cap in \metricsSmall{
    \begin{figure}[p]
        \centering
        \includegraphics[width=\textwidth]{chapters/experiments/img/merged_plots/per1_all/\metric.png}
        \caption{\cap \space w zależności od liczby wierzchołków}
        \label{fig:small_\metric}
    \end{figure}
}

\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{chapters/experiments/img/merged_plots/per1_all/missed.png}
    \caption{Liczba nieudanych prób tworzenia krawędzi w zależności od liczby wierzchołków - próbkowanie dwufazowe}
    \label{fig:small_missed}
\end{figure}

TODO: Komentarz do wyników

\newpage

\subsection{Badanie stabilności dla dużych instancji}
W tej sekcji opisano badania przeprowadzone dla instancji o rozmiarze 48 i większym.
Próbkowanie przeprowadzono przez ustaloną z góry liczbę powtórzeń, zapisując stan przestrzeni po zakończeniu każdego powtórzenia.

Próbkowanie algorytmem snowball wykonano z następującymi parametrami:
\begin{itemize}
    \item $w_{len}$ - długość losowego spaceru - 10000
    \item $m$ - liczba prób przeszukania sąsiedztwa - 100
    \item $depth$ - głębokość przeszukiwania - 3
\end{itemize}

Próbkowanie algorytmem \textit{snowball} prowadzono do zakończenia losowego spaceru lub osiągnięcia liczby 100000 wierzchołków.
Dla instancji \textbf{cliques\_50} z powodu małej liczby optimów lokalnych zapis wykonywano co 100 znalezionych wierzchołków.
Dla pozostałych instancji stan próbkowania zapisywany był co 1000 znalezionych wierzchołków.

Próbkowanie algorytmem dwufazowym przeprowadzono z następującymi parametrami:
\begin{itemize}
    \item $n_{max}$ - żądana liczba wierzchołków - 1000
    \item $n_{att}$ - liczba prób generowania wierzchołków - 1000
    \item $e_{att}$ - liczba prób generowania krawędzi - 1000
    \item $n_{runs}$ - liczba powtórzeń - 100
\end{itemize}

Po zakończeniu próbkowania dla każdego zapisanego stanu przestrzeni obliczono wartości badanych miar. W ten sposób uzyskano
wartości miar dla różnych etapów próbkowania przestrzeni.

Utworzono wykresy przedstawiające zależność wartości miar od liczby spróbkowanych wierzchołków.
Przedstawiono je na rysunkach od \ref{fig:main_snowball_edge_count} do \ref{fig:main_twophase_missed}.

\def\metrics{
    {edge_count/Liczba krawędzi},
    {edge_to_node/Stosunek liczby krawędzi do liczby wierzchołków},
    {assortativity_deg/Współczynnik różnorodności grafu},
    {avg_fitness/Średnia wartość funkcji celu w znalezionych optimach lokalnych},
    {conrel/Współczynnik conrel},
    {density/Gęstość grafu},
    {distLO/Współczynnik distLO},
    {reciprocity/Współczynnik wzajemności grafu},
    {largest_clique_size/Rozmiar największej kliki w grafie},
    {num_sources/Liczba źródeł w grafie},
    {num_sinks/Liczba ścieków w grafie},
    {num_subsinks/Liczba subsinks w grafie},
    {avg_in_degree/Średni stopień wchodzący wierzchołków w grafie},
    {max_in_degree/Maksymalny stopień wchodzący wśród wierzchołków w grafie},
    {max_out_degree/Średni stopień wychodzący wierzchołków w grafie},
    {avg_out_degree/Maksymalny stopień wychodzący wśród wierzchołków w grafie},
    {avg_loop_weight/Średnia waga pętli w grafie},
    {avg_path_len/Średnia waga pętli w grafie},
    {avg_go_path_len/Średnia długość istniejących ścieżek do globalnego optimum},
    {max_go_path_len/Długość najdłuższej istniejącej ścieżki do globalnego optimum},
    {go_path_ratio/Stosunek liczby wierzchołków, z których istnieje ścieżka do globalnego optimum do liczby wszystkich wierzchołków},
    {funnel_num/Liczba lejów w przestrzeni},
    {max_funnel_size/Rozmiar największego leja w przestrzeni},
    {mean_funnel_size/Średni rozmiar lejów w przestrzeni},
    {num_cc/Liczba spójnych podgrafów},
    {largest_cc/Rozmiar największego spójnego podgrafu},
    {largest_cc_radius/Promień największego spójnego podgrafu}}

\foreach \metric/\cap in \metrics{
    \begin{figure}[p]
        \centering
        \includegraphics[width=\textwidth]{chapters/experiments/img/merged_plots/main_snowball/\metric.png}
        \caption{\cap \space w zależności od liczby wierzchołków - próbkowanie snowball}
        \label{fig:main_snowball_\metric}
    \end{figure}
}

TODO: wstawić główne wyniki z twophase, jak już będą, Komentarz do wyników